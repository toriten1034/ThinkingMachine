# MN-Coreチャレンジに参加したときの日記
PFNがMN-Coreを開放したプログラミングコンテストを行っているんで参加する。

## カレンダー
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
  <tr>
    <th>日</th>
    <th>月</th>
    <th>火</th>
    <th>水</th>
    <th>木</th>
    <th>金</th>
    <th>土</th>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td><a href="#h1-2">25</a></td>
  </tr>
  <tr>
    <td><a href="#h1-3">26</a></td>
    <td><a href="#h1-4">27</a></td>
    <td><a href="#h1-5">28</a></td>
    <td><a href="#h1-6">29</a></td>
    <td><a href="#h1-7">30</a></td>
    <td>31</td>
    <td>1</td>
  </tr>
  <tr>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
  </tr>
  <tr>
    <td>9</td>
    <td>10</td>
    <td>11</td>
    <td>12</td>
    <td>13</td>
    <td>14</td>
    <td>15</td>
  </tr>
  <tr>
    <td>16</td>
    <td>17</td>
    <td>18</td>
    <td>19</td>
    <td>20</td>
    <td>21</td>
    <td>22</td>
  </tr>
  <tr>
    <td>23</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>


***
# 8/25 とりあえず入門

## やったこと
[MN-Core勉強会](https://www.youtube.com/watch?v=U4HjE2S8wAY)のYouTubeを視聴しました。また、MN-Coreの[開発者マニュアル](https://projects.preferred.jp/mn-core/assets/mncore2_dev_manual_ja.pdf)をKindleにダウンロードして読みました。

## 知見

### チップ構造
- チップ -&gt; L2B -&gt; L1B -&gt; MAB -&gt; &#123;PE \| MAU&#125; という包括的な構造になっているらしい。
- PE (Processing Element)：普通のCPUの延長線上っぽい。
- Matrix Arithmetic Unit：行列演算を行うユニット、転置やMACができるらしい。TPUのシストリックアレイに似たものかもしれない。
- L1B：MABが16個とか32個の集合で、L1B MemoryやL1B Reduction Unitが含まれる。
- L2B：L1Bを8個束ねたものらしい。L2B MemoryやL2B Reduction Unitが含まれる。

### メモリ空間の分離
- PEからグローバルメモリにアクセスすることができない。PEからアクセス可能なのはPEが持つメモリ利用域だけ。
- PEでデータを利用するためには、DRAM -&gt; L2B -&gt; L1B -&gt; PEという段階的な転送が必要になる。

### 演算の制御
- PEに命令発行ユニットがない。
- PCI Expressから命令を流し込んで実行する。

- 命令の種類
  - PE命令
  - MAU命令
  - L1B命令：L1B &lt;=&gt; MAB間の転送命令
  - L2B命令：L2B &lt;=&gt; L1B間の転送命令
  - DRAM/PDM命令：L2B &lt;=&gt; DRAM間の転送命令

これらの命令が次のようなVLIWになる。

| PE命令 | MAU命令 | L1B転送命令 | L2B転送命令 | DRAM命令 |
|--------|---------|-------------|-------------|----------|

## 感想とかいろいろ
- 機械学習の性質から決定論的にメモリアクセスを行うのでキャッシュがいらないのかもしれない。
- ハードウェアの機能をソフトウェアに置き換えている。→可塑性が高く、効率的にできる。
- 機械学習のノウハウから強力なコンパイラが構築でき、MN-Coreを効果的に扱えるようになるっぽい。
- PyTorchでGPUのように扱えるソフトウェアスタックが用意されている。
- データパラレルの時代はAll Reduce（データを配布して計算して集める処理）について考えればよかったが、現在のLLMでは直列のパイプラインが重要。
- PFN、IIJ、JAISTが共同研究している。→この前VDECで回ってきたAIプロセッサの公募はもしかしてこれか？
- なんというかCGRAに近い、NAISTで開発されていたEMAXに似ている。

## 積み残し
それぞれの命令の機能がまだわからない。明日は命令のリストを作ってチェックする。


***
# 8/26 開発者マニュアルの読み込み

## やったこと
引き続きMN-Coreの[開発者マニュアル](https://projects.preferred.jp/mn-core/assets/mncore2_dev_manual_ja.pdf)を読みました。命令数が多すぎて理解できなかったので、完全な命令セットの作成は諦めました。

## 知見
パッと読んで理解できなかった点について以下のようにまとめました。

### PEのメモリ構成がよくわからない
PEに含まれるレジスタファイルなどの名前がよくわからない
| メモリ名 | 1PEあたりのメモリ容量 | 読み書き |
|----------|-----------------------|----------|
| **GRF0** | 256ワード              | 1R1W     |
| **GRF1** | 256ワード              | 1R1W     |
| **T**    | 8ワード                | 1R1W     |
| **LM0**  | 2Ki                    | 1RW      |
| **LM1**  | 2Ki                    | 1RW      |
GRFが1R1Wなので、ダブルポンピングメモリかロジックで構成されている可能性があります。

### サンプルコードが何をやっているのか分からない
ダウンロードした`judge`にサンプルコードが含まれていますが、何をしているのかよくわからないので、読み進めています。

/content/judge/example/hello_world/example.vsm


```
imm ui"0" $n0
imm ui"0x48656c6c" $r2
imm ui"0x6f2c2077" $r3
imm ui"0x6f726c64" $r0
imm ui"0x21000000" $r1

sor $subpeid $n0 $omr1
nop
lpassa $lr2 $lr0/$imr1

nop/2

# d get $lr0n0c0b0m0 1

l1bmrsbor $llr0v $llb0
nop/3

# d get $lb0n0c0b0 1

l2bmrsbor $lb0 $lc0

# d get $lc0n0c0 1

nop/3
mvp/n64i01 $lc0 $d0
nop; wait i01
```

#### imm命令
imm命令は即値命令で、即値リテラルを2ワード出力します。
```
imm ui"0" $n0
``` 
について考えるとまず**immu**ではないのでuオプションは無効である。
次に**ui"0"**は符号ナシの整数型0を表している。RISC-Vだと整数型と浮動小数点型とレジスタが分離されていたりするので、同じレジスタに異なる型のデータを格納できるのは結構意外である。そして**$n**はLM1レジスタを表しているらしい。続く数字の**0**はアドレスらしい。
つまり、この命令はLM1の0番地に符号なし整数0を格納するという処理だと思う（多分）

MN-Coreのマニュアルに長語とか単語とか半語とか出てくるが
- 半語 (半精度): 16bit
- 単語 (単精度): 32bit
- 長語 (倍精度): 64bit
ということらしい。

それぞれのレジスタの指定方法は次の表の通りである
|記号|メモリ種類|アクセスワード|
|---|---|---|
|$lc|L2BM|長語|
|$lb|L1BM|長語|
|$llb|L1BM|2 長語|
|$r, $s, $m, $n|GRF0,GRF1,LM0,LM1|単語|
|$lr, $ls, $lm, $ln|GRF0,GRF1,LM0,LM1|長語|
|$llr, $lls, $llm, $lln|GRF0,GRF1,LM0,LM1|2 長語|
|$t, $lt|Tレジスタ|長語|
|$llt|Tレジスタ|2 長語|
もっと細かい設定とかあるがマニュアルを自分で読んでほしい

1上の情報に従うと以下の命令はコメントのような感じだと思う
```
imm ui"0" $n0          #LM1の0番地に半語として0を書き込む
imm ui"0x48656c6c" $r2 #GRF0の2番地に半語として"0x48656c6c"を書き込む
imm ui"0x6f2c2077" $r3 #GRF0の3番地に半語として"0x6f2c2077"を書き込む
imm ui"0x6f726c64" $r0 #GRF0の0番地に半語として"0x6f726c64"を書き込む
imm ui"0x21000000" $r1 #GRF0の1番地に半語として"0x21000000"を書き込む
```

 #### ALU命令
```
sor $subpeid $n0 $omr1
``` 
**sor**は**or**命令に対して、精度指定の**s**がついているため、半精度です。レジスタに
第一オペランドの**$subpeid**は自分のPEの番号でビット幅は2bitらしいです。PEは4つでL1Bを構成しているからL1B内のアドレスってことで大丈夫かな？
第２オペランドの**$n0**はLM1の0番地の半語アクセスですね。
最後のオペランドの**$omr1**マスクレジスタです。マスクレジスタの1番地ってことになりますね。マスクレジスタは条件分岐を実現するための特殊なレジスタであり、ビットの状態によって計算をスキップしたりします。自分のPEが持つIDと0を論理和演算してマスクレジスタに代入していることになりますね。4bitしかないので半語で扱うのかな？

### 感想とかいろろ
MN-CoreのPEについてわかってきたが、メモリ転送に関しては、まだまだ分からない

### 積み残し
サンプルコードのまだ読んでない残りの行があるので、明日は残りの行を読んでいきます。

***

# 8/27 つづきとか

## やったこと
引き続きサンプルコードを読んでいきます。

#### nop命令
いわゆるnop命令であり、特に何もしないのであるが、MN-Coreでは転送などの待ちをnop命令で調整しないといけないらしい。
nopのあとに**/**がついていることがあるが、これは複数回動かすことを示すためのシンタックスシュガーらしい

#### passa命令
コピー命令である。MN-Coreの命令に接頭辞をつけちゃう命名スタイルは正直すごく読みにくい
```
lpassa $lr2 $lr0/$imr1
```
というプログラムは、まず接頭辞の`l`がついているので長語でのコピーを表している。次に第一オペランドである**$lr2**はコピーもとであろう、GRF0の2番地ということになる。
最後の**$lr0/$imr1**とあるが、$lr0は書き込み先のレジスタと先頭の番地であり、$imr1は書き込みのマスクであると考えられる。

#### l1bmr命令
```
l1bmrsbor $llr0v $llb0
```
この命令はに L1BM-L2BM 間の転送を行う命令であるのでかなりややこしい。

この命令の構造は以下ののような感じになってる
```
l1bmr<rrn_opcode> <src> $lb<addr_b>
```
オペコードの意味を考えると

- **&ltrrn_opcode&gt**は縮約演算していというものでsborはshort型（半語）でborは論理orを表している。
- **src**
orしているのでそれぞれのpeから1ワードづつ読み出して、それぞれのPE番目のデータとPEのメモリのsrcからcycleでインクリメント下値をorを計算しているっぽい？難しすぎる。

意味がわからなすぎるので疑似コードを頑張って読んでいく
```
for cycle = 0:4 //４回繰り返す
    forall group,l2b,l1b　//すべてのブロックで演算を行う。
      LongWord data[4]　//配列の宣言
      data[:] = get_unit_value(rrn_opcode) //PEメモリのオペランドの単位元を入れる。orだったら全部０
      forall mab,pe //すべてのmabおよびpeで演算をする？
          //dataうちPEのIDが対応するアドレスに対してdataのPEのIDが対応するものと、サイクル番目のアドレスのデータを読み出してor
          data[pe] = rrn_opcode(data[pe], MEM[group][l2b][l1b][mab][pe].refer_pemem(src,cycle))　
      uint_t dst_addr = addr_b + cycle * 4　//出力アドレスをインクリメント
      MEM[group][l2b][l1b].l1bm[dst_addr:dst_addr+4] = data[0:4] //4こベクトルでコピー
```


#### l2bmr命令



#### mvp命令
mv命令は複雑らしい、PFNの人が文法が複雑だって言うんだから俺に理解するのは無理だろう
mvp/n64i01 $lc0 $d0
まずmvのあとについている**n64**は転送サイズが64byteであることを表しているらしい。その後の**i01**はタグ番号らしい。
第２オペランドが転送元であるL2BM、第３オペランドDRAMであり転送先を表す。
つまりこの命令はL2BMの０番地からDRAMの０番地へ転送するという認識でいいのかな？

#### 全体を読み直す
```
imm ui"0" $n0          # LM1の0番地に半語として0を書き込む
imm ui"0x48656c6c" $r2 # GRF0の2番地に半語として"0x48656c6c"を書き込む
imm ui"0x6f2c2077" $r3 # GRF0の3番地に半語として"0x6f2c2077"を書き込む
imm ui"0x6f726c64" $r0 # GRF0の0番地に半語として"0x6f726c64"を書き込む
imm ui"0x21000000" $r1 # GRF0の1番地に半語として"0x21000000"を書き込む

sor $subpeid $n0 $omr1 #半精度（半語）で自分のPE番号と、LM1の０番地（つまり０）とorを計算する
nop                    # １サイクル休み
lpassa $lr2 $lr0/$imr1 # GRF0の２番地の内容をGRF0の０番地にマスクして長語でコピーする（２を先頭として４アドレス行われる？）

nop/2                  # 2サイクル休み

# d get $lr0n0c0b0m0 1

l1bmrsbor $llr0v $llb0 #GRF0の０番地を２長語でorしてGRF1の０番地に書き込む
nop/3

# d get $lb0n0c0b0 1

l2bmrsbor $lb0 $lc0

# d get $lc0n0c0 1

nop/3
mvp/n64i01 $lc0 $d0
nop; wait i01
```

## 感想
RISCしか触ってこなかったので、正直なところ意味不明過ぎて困惑している。RISC-Vのベクトル命令ですら混乱するのに、なんやこれ？

### 積み残し
例題をときたかったけど、まだ終わってない。明日からコンテスト開場なので頑張りたい。


***
# 8/27 例題解くぞ！

とりあえず例題をときました。今日は説明が面倒臭いので、とりあえず初見で思いついたクソ解法を貼っておきます。
例題の3問は解答に関してネタバレが許可されているんですが、それ以降の問題はネタバレが禁止されています。

なので、明日からの問題は解けたか解けてないかと、学ぶ必要を感じた知識の解説だけ行っていきます。

### Welcome
```
iinc $m[0,1,2,3] $n[0,1,2,3]
iinc $m[4,5,6,7] $n[4,5,6,7]
iinc $m[8,9,10,11] $n[8,9,10,11]
iinc $m[12,13,14,15] $n[12,13,14,15]
```
inc命令を知らなかったんですが、とりあえずサンプルコードベースに書きました。

### Plus2
```
linc $lm0v $lm0v
nop
nop
linc $lm0v $ln0v 
nop
nop
linc $lm8v $lm8v
nop
nop
linc $lm8v $ln8v 
nop
nop
linc $lm16v $lm16v
nop
nop
linc $lm16v $ln16v 
nop
nop
linc $lm24v $lm24v
nop
nop
linc $lm24v $ln24v 
nop
nop
linc $lm32v $lm32v
nop
nop
linc $lm32v $ln32v 
```
頭の悪さがにじみ出ていますね。

### A+B
```
iadd $lm0v $ln0v $lr0v
nop/2
ipassa $lr0v $lm32v
nop/2
iadd $lm8v $ln8v $lr0v
nop/2
ipassa $lr0v $lm40v
nop/2
iadd $lm16v $ln16v $lr0v
nop/2
ipassa $lr0v $lm48v
nop/2
iadd $lm24v $ln24v $lr0v
nop/2
ipassa $lr0v $lm56v
```
なんか怖いからとりあえずnopを入れるクセがついてしまっています。多分必要以上にnopが入ってるんじゃないかな？

## 結果
![alt text](imgs/Passed.png)
とりあえず短くは無いですが3つとも解けていますね。疲れた、眠い。明日は

***
# 8/29 1問解いたぞ！
眠いので今日は前回の問題の最短解をとき、続きの問題を1問だけときました。
一応今回のコンテストの目標は全部の問題を咲いたんじゃなくていいから、解くこととします。
![alt text](imgs/Passed_29.png)
眠いです。おやすみ。

### 積み残し
明日は以下の内容について調べて記事にしたいと思います。
- MAUを使った演算
- PEのIDによるマスキング
- nop命令の発生条件

***
# 8/30 お勉強するぞ
今日は昨日の積み残しである3つのうち以下の2つだけに関してお勉強します。
- PEのIDによるマスキング
- nop命令の発生条件
2つに絞った理由はMAUは複雑過ぎて今日1日で学ぶのは無理だと思ったからです。

## nop命令の発生条件
おさらいとして、nop命令はデータハザードを回避するために挿入されます。
まずデータハザードについてお勉強します。データハザードはパイプラインプロセッサにおいてデータの依存関係を無視した参照が発生した場合に計算結果がおかしくなる現象です。<br>
**c = a + b**<br>
**d = c + a**<br>
みたいな計算があった場合に**c**の計算が終わる前に**c + a**を始めたら、答えがおかしくなってしまいます。

このような場合**c**をメモリに書き戻す前に直接**a**との加算に接続するフォワーディングや、**c**の計算が終わるまでパイプラインを休ませるパイプラインインターロックなんかが存在します。MN-Coreはこれらのフォワーディングやパイプラインインターロックの機能を持ちません。通常のRISC-Vであれば、複数の実装で同一のバイナリを実行できなければいけませんが、MN-CoreはMN-Coreしか無いので、そのような操作は事前に予測可能であり、コンパイル時に行えばよいという設計方針のようです。

MN-Coreの開発者マニュアルの3.6.4によると、MN-Coreのデータハザードには**データ競合**と**ポート競合**の二種類があるようです。データ競合は書き込みが終わるまで待たないのに読み出してしまうことによって発生する競合。ポート競合はアドレス線などのハードウェア資源の解法を待たなければいけないことによって発生するようです。

MN-Coreにはたくさんの階層のメモリが存在しますが、L1BMやL2BMのような階層をまたぐ話はまた今度にします。

### PEメモリ書き込み＝＞PEメモリ読み出し
いままでプログラミングしてきたものを見るとわかると思いますが、PE間のデータ転送においてもnopが必要になります。
ここでPEに搭載されてるメモリの表を思い出します。

| メモリ名 | 読み書き |
|----------|----------|
| **GRF0** | 1R1W     |
| **GRF1** | 1R1W     |
| **T**    | 1R1W     |
| **LM0**  | 1RW      |
| **LM1**  | 1RW      |

読み書きが1RWと1R1Wの二種類が存在しますね。この表記はRAMの読み書き機能を表現するための表記で1R1Wは1サイクルで1回の読み出しと、1回の書き込みに対応していることを表します。つまりデュアルポートSRAMってやつです。
次に1RWですが、これは1サイクルに1回の読み出しか、もしくは書き込みが可能なことを表しています。

- LM0/LM1（おそらくTも）に対しては書き込んだあと、ポート衝突により2ステップ開けてから出ないと読み出しを開始できない。
- GRF0/GRF1に書き込んだあとは、データ競合により1ステップ開けてから出ないと同じアドレスからは読み出し書き込みができない、しかし異なるアドレスであれば同時に読み書きできる.
- Tレジスタに書き込んだあとはデータ競合により1ステップ開けてからでないと読み出しを開始できない。

ということらしいです。メモリの構造から考えてもこれらの制約は理にかなってますね。
色々サンプルコードを示して実験してみたいですが、時間が無いので今日はこのくらいにしておきます。

## PEのIDによるマスキング

MN-CoreにはOMRというマスクレジスタが存在します。このレジスタはデータを保持するためのレジスタではなく、フラグを保持するためのレジスタであり、PEのメモリ書き込み時または、演算結果出力時に指定した箇所についての書き込みのスキップやゼロフラッシュが可能です。これにより擬似的な条件分岐が実現できます。なんだかSIMTみたいですね。

マスクレジスタを使うことでPEメモリの殆どにマスクを適用可能なようです。
このレジスタは出力専用のようでMAU命令かALU命令でのみ書き込みが可能なようです。

以下のコードはマニュアルからの引用ですが、/のあとに1になっているサイクルのみで書き込みが行われるようです。面白いですね。
'''
lpassa $lm0v $lr0v/0001
lpassa $lm8v $lr8v/1000
'''

### 積み残し
5問目の解法は頭の中に出来上がってるので実装する。