# MN-Coreチャレンジに参加したときの日記
PFNがMN-Coreを開放したプログラミングコンテストを行っているんで参加する。
***
## 8/25 とりあえず入門

### やったこと
[MN-Core勉強会](https://www.youtube.com/watch?v=U4HjE2S8wAY)のYouTubeを視聴しました。また、MN-Coreの[開発者マニュアル](https://projects.preferred.jp/mn-core/assets/mncore2_dev_manual_ja.pdf)をKindleにダウンロードして読みました。

### 知見

#### チップ構造
- チップ -&gt; L2B -&gt; L1B -&gt; MAB -&gt; &#123;PE \| MAU&#125; という包括的な構造になっているらしい。
- PE (Processing Element)：普通のCPUの延長線上っぽい。
- Matrix Arithmetic Unit：行列演算を行うユニット、転置やMACができるらしい。TPUのシストリックアレイに似たものかもしれない。
- L1B：MABが16個とか32個の集合で、L1B MemoryやL1B Reduction Unitが含まれる。
- L2B：L1Bを8個束ねたものらしい。L2B MemoryやL2B Reduction Unitが含まれる。

#### メモリ空間の分離
- PEからグローバルメモリにアクセスすることができない。PEからアクセス可能なのはPEが持つメモリ利用域だけ。
- PEでデータを利用するためには、DRAM -&gt; L2B -&gt; L1B -&gt; PEという段階的な転送が必要になる。

#### 演算の制御
- PEに命令発行ユニットがない。
- PCI Expressから命令を流し込んで実行する。

- 命令の種類
  - PE命令
  - MAU命令
  - L1B命令：L1B &lt;=&gt; MAB間の転送命令
  - L2B命令：L2B &lt;=&gt; L1B間の転送命令
  - DRAM/PDM命令：L2B &lt;=&gt; DRAM間の転送命令

これらの命令が次のようなVLIWになる。

| PE命令 | MAU命令 | L1B転送命令 | L2B転送命令 | DRAM命令 |
|--------|---------|-------------|-------------|----------|

### 感想とかいろいろ
- 機械学習の性質から決定論的にメモリアクセスを行うのでキャッシュがいらないのかもしれない。
- ハードウェアの機能をソフトウェアに置き換えている。→可塑性が高く、効率的にできる。
- 機械学習のノウハウから強力なコンパイラが構築でき、MN-Coreを効果的に扱えるようになるっぽい。
- PyTorchでGPUのように扱えるソフトウェアスタックが用意されている。
- データパラレルの時代はAll Reduce（データを配布して計算して集める処理）について考えればよかったが、現在のLLMでは直列のパイプラインが重要。
- PFN、IIJ、JAISTが共同研究している。→この前VDECで回ってきたAIプロセッサの公募はもしかしてこれか？
- なんというかCGRAに近い、NAISTで開発されていたEMAXに似ている。

### 積み残し
それぞれの命令の機能がまだわからない。明日は命令のリストを作ってチェックする。


***
## 8/26 開発者マニュアルの読み込み

### やったこと
引き続きMN-Coreの[開発者マニュアル](https://projects.preferred.jp/mn-core/assets/mncore2_dev_manual_ja.pdf)を読みました。命令数が多すぎて理解できなかったので、完全な命令セットの作成は諦めました。

### 知見
パッと読んで理解できなかった点について以下のようにまとめました。

#### PEのメモリ構成がよくわからない
| メモリ名 | 1PEあたりのメモリ容量 | 読み書き |
|----------|-----------------------|----------|
| **GRF0** | 256ワード              | 1R1W     |
| **GRF1** | 256ワード              | 1R1W     |
| **T**    | 8ワード                | 1R1W     |
| **LM0**  | 2Ki                    | 1RW      |
| **LM1**  | 2Ki                    | 1RW      |
GRFが1R1Wなので、ダブルポンピングメモリかロジックで構成されている可能性があります。

#### サンプルコードが何をやっているのか分からない
ダウンロードした`judge`にサンプルコードが含まれていますが、何をしているのかよくわからないので、読み進めています。

/content/judge/example/hello_world/example.vsm


```
imm ui"0" $n0
imm ui"0x48656c6c" $r2
imm ui"0x6f2c2077" $r3
imm ui"0x6f726c64" $r0
imm ui"0x21000000" $r1

sor $subpeid $n0 $omr1
nop
lpassa $lr2 $lr0/$imr1

nop/2

# d get $lr0n0c0b0m0 1

l1bmrsbor $llr0v $llb0
nop/3

# d get $lb0n0c0b0 1

l2bmrsbor $lb0 $lc0

# d get $lc0n0c0 1

nop/3
mvp/n64i01 $lc0 $d0
nop; wait i01
```

**★imm命令**
imm命令は即値命令で、即値リテラルを2ワード出力します。
```
imm ui"0" $n0
``` 
について考えるとまず**immu**ではないのでuオプションは無効である。
次に**ui"0"**は符号ナシの整数型0を表している。RISC-Vだと整数型と浮動小数点型とレジスタが分離されていたりするので、同じレジスタに異なる型のデータを格納できるのは結構意外である。そして**$n**はLM1レジスタを表しているらしい。続く数字の**0**はアドレスらしい。
つまり、この命令はLM1の0番地に符号なし整数0を格納するという処理だと思う（多分）

NM-Coreのマニュアルに長語とか単語とか半語とか出てくるが
- 半語 (半精度): 16bit
- 単語 (単精度): 32bit
- 長語 (倍精度): 64bit
ということらしい。

それぞれのレジスタの指定方法は次の表の通りである
|記号|メモリ種類|アクセスワード|
|---|---|---|
|$lc|L2BM|長語|
|$lb|L1BM|長語|
|$llb|L1BM|2 長語|
|$r, $s, $m, $n|GRF0,GRF1,LM0,LM1|単語|
|$lr, $ls, $lm, $ln|GRF0,GRF1,LM0,LM1|長語|
|$lr, $ls, $lm, $ln|GRF0,GRF1,LM0,LM1|2 長語|
|$t, $lt|Tレジスタ|長語|
|$llt|Tレジスタ|2 長語|
もっと細かい設定とかあるがマニュアルを自分で読んでほしい

1上の情報に従うと以下の命令はコメントのような感じだと思う
```
imm ui"0" $n0          #LM1の0番地に半語として0を書き込む
imm ui"0x48656c6c" $r2 #GRF0の2番地に半語として"0x48656c6c"を書き込む
imm ui"0x6f2c2077" $r3 #GRF0の3番地に半語として"0x6f2c2077"を書き込む
imm ui"0x6f726c64" $r0 #GRF0の0番地に半語として"0x6f726c64"を書き込む
imm ui"0x21000000" $r1 #GRF0の1番地に半語として"0x21000000"を書き込む
```

 **★ALU命令**
```
sor $subpeid $n0 $omr1
``` 
**sor**は**or**命令に対して、精度指定の**s**がついているため、半精度です。レジスタに
第一オペランドの**$subpeid**は自分のPEの番号でビット幅は2bitらしいです。PEは4つでL1Bを構成しているからL1B内のアドレスってことで大丈夫かな？
第２オペランドの**$n0**はLM1の0番地の半語アクセスですね。
最後のオペランドの**$omr1**マスクレジスタです。マスクレジスタの1番地ってことになりますね。マスクレジスタは条件分岐を実現するための特殊なレジスタであり、ビットの状態によって計算をスキップしたりします。自分のPEが持つIDと0を論理和演算してマスクレジスタに代入していることになりますね。4bitしかないので半語で扱うのかな？

#### 感想とかいろろ
MN-CoreのPEについてわかってきたが、メモリ転送に関しては、まだまだ分からない

#### 積み残し
サンプルコードのまだ読んでない残りの行があるので、明日は残りの行を読んでいきます。