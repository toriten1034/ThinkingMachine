# MN-Coreチャレンジに参加したときの日記
PFNがMN-Coreを開放したプログラミングコンテストを行っているんで参加する。
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tr><th colspan="7">Calendar</th></tr>
    <tr><th>Mon</th><th>Tue</th><th>Wed</th><th>Thu</th><th>Fri</th><th>Sat</th><th>Sun</th></tr>
    <tr><td></td><td></td><td> <a href="#h1-2">25</a></td><td><a href="#h1-3">26</a></td><td><a href="#h1-4">27</a></td><td>28</td><td>29</td></tr>
    <tr><td>30</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr>
    <tr><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td></tr>
    <tr><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td></tr>
    <tr><td>21</td><td>22</td><td>23</td><td>24</td></tr>
</table>


***
# 8/25 とりあえず入門

## やったこと
[MN-Core勉強会](https://www.youtube.com/watch?v=U4HjE2S8wAY)のYouTubeを視聴しました。また、MN-Coreの[開発者マニュアル](https://projects.preferred.jp/mn-core/assets/mncore2_dev_manual_ja.pdf)をKindleにダウンロードして読みました。

## 知見

### チップ構造
- チップ -&gt; L2B -&gt; L1B -&gt; MAB -&gt; &#123;PE \| MAU&#125; という包括的な構造になっているらしい。
- PE (Processing Element)：普通のCPUの延長線上っぽい。
- Matrix Arithmetic Unit：行列演算を行うユニット、転置やMACができるらしい。TPUのシストリックアレイに似たものかもしれない。
- L1B：MABが16個とか32個の集合で、L1B MemoryやL1B Reduction Unitが含まれる。
- L2B：L1Bを8個束ねたものらしい。L2B MemoryやL2B Reduction Unitが含まれる。

### メモリ空間の分離
- PEからグローバルメモリにアクセスすることができない。PEからアクセス可能なのはPEが持つメモリ利用域だけ。
- PEでデータを利用するためには、DRAM -&gt; L2B -&gt; L1B -&gt; PEという段階的な転送が必要になる。

### 演算の制御
- PEに命令発行ユニットがない。
- PCI Expressから命令を流し込んで実行する。

- 命令の種類
  - PE命令
  - MAU命令
  - L1B命令：L1B &lt;=&gt; MAB間の転送命令
  - L2B命令：L2B &lt;=&gt; L1B間の転送命令
  - DRAM/PDM命令：L2B &lt;=&gt; DRAM間の転送命令

これらの命令が次のようなVLIWになる。

| PE命令 | MAU命令 | L1B転送命令 | L2B転送命令 | DRAM命令 |
|--------|---------|-------------|-------------|----------|

## 感想とかいろいろ
- 機械学習の性質から決定論的にメモリアクセスを行うのでキャッシュがいらないのかもしれない。
- ハードウェアの機能をソフトウェアに置き換えている。→可塑性が高く、効率的にできる。
- 機械学習のノウハウから強力なコンパイラが構築でき、MN-Coreを効果的に扱えるようになるっぽい。
- PyTorchでGPUのように扱えるソフトウェアスタックが用意されている。
- データパラレルの時代はAll Reduce（データを配布して計算して集める処理）について考えればよかったが、現在のLLMでは直列のパイプラインが重要。
- PFN、IIJ、JAISTが共同研究している。→この前VDECで回ってきたAIプロセッサの公募はもしかしてこれか？
- なんというかCGRAに近い、NAISTで開発されていたEMAXに似ている。

## 積み残し
それぞれの命令の機能がまだわからない。明日は命令のリストを作ってチェックする。


***
# 8/26 開発者マニュアルの読み込み

## やったこと
引き続きMN-Coreの[開発者マニュアル](https://projects.preferred.jp/mn-core/assets/mncore2_dev_manual_ja.pdf)を読みました。命令数が多すぎて理解できなかったので、完全な命令セットの作成は諦めました。

## 知見
パッと読んで理解できなかった点について以下のようにまとめました。

### PEのメモリ構成がよくわからない
PEに含まれるレジスタファイルなどの名前がよくわからない
| メモリ名 | 1PEあたりのメモリ容量 | 読み書き |
|----------|-----------------------|----------|
| **GRF0** | 256ワード              | 1R1W     |
| **GRF1** | 256ワード              | 1R1W     |
| **T**    | 8ワード                | 1R1W     |
| **LM0**  | 2Ki                    | 1RW      |
| **LM1**  | 2Ki                    | 1RW      |
GRFが1R1Wなので、ダブルポンピングメモリかロジックで構成されている可能性があります。

### サンプルコードが何をやっているのか分からない
ダウンロードした`judge`にサンプルコードが含まれていますが、何をしているのかよくわからないので、読み進めています。

/content/judge/example/hello_world/example.vsm


```
imm ui"0" $n0
imm ui"0x48656c6c" $r2
imm ui"0x6f2c2077" $r3
imm ui"0x6f726c64" $r0
imm ui"0x21000000" $r1

sor $subpeid $n0 $omr1
nop
lpassa $lr2 $lr0/$imr1

nop/2

# d get $lr0n0c0b0m0 1

l1bmrsbor $llr0v $llb0
nop/3

# d get $lb0n0c0b0 1

l2bmrsbor $lb0 $lc0

# d get $lc0n0c0 1

nop/3
mvp/n64i01 $lc0 $d0
nop; wait i01
```

#### imm命令
imm命令は即値命令で、即値リテラルを2ワード出力します。
```
imm ui"0" $n0
``` 
について考えるとまず**immu**ではないのでuオプションは無効である。
次に**ui"0"**は符号ナシの整数型0を表している。RISC-Vだと整数型と浮動小数点型とレジスタが分離されていたりするので、同じレジスタに異なる型のデータを格納できるのは結構意外である。そして**$n**はLM1レジスタを表しているらしい。続く数字の**0**はアドレスらしい。
つまり、この命令はLM1の0番地に符号なし整数0を格納するという処理だと思う（多分）

NM-Coreのマニュアルに長語とか単語とか半語とか出てくるが
- 半語 (半精度): 16bit
- 単語 (単精度): 32bit
- 長語 (倍精度): 64bit
ということらしい。

それぞれのレジスタの指定方法は次の表の通りである
|記号|メモリ種類|アクセスワード|
|---|---|---|
|$lc|L2BM|長語|
|$lb|L1BM|長語|
|$llb|L1BM|2 長語|
|$r, $s, $m, $n|GRF0,GRF1,LM0,LM1|単語|
|$lr, $ls, $lm, $ln|GRF0,GRF1,LM0,LM1|長語|
|$llr, $lls, $llm, $lln|GRF0,GRF1,LM0,LM1|2 長語|
|$t, $lt|Tレジスタ|長語|
|$llt|Tレジスタ|2 長語|
もっと細かい設定とかあるがマニュアルを自分で読んでほしい

1上の情報に従うと以下の命令はコメントのような感じだと思う
```
imm ui"0" $n0          #LM1の0番地に半語として0を書き込む
imm ui"0x48656c6c" $r2 #GRF0の2番地に半語として"0x48656c6c"を書き込む
imm ui"0x6f2c2077" $r3 #GRF0の3番地に半語として"0x6f2c2077"を書き込む
imm ui"0x6f726c64" $r0 #GRF0の0番地に半語として"0x6f726c64"を書き込む
imm ui"0x21000000" $r1 #GRF0の1番地に半語として"0x21000000"を書き込む
```

 #### ALU命令
```
sor $subpeid $n0 $omr1
``` 
**sor**は**or**命令に対して、精度指定の**s**がついているため、半精度です。レジスタに
第一オペランドの**$subpeid**は自分のPEの番号でビット幅は2bitらしいです。PEは4つでL1Bを構成しているからL1B内のアドレスってことで大丈夫かな？
第２オペランドの**$n0**はLM1の0番地の半語アクセスですね。
最後のオペランドの**$omr1**マスクレジスタです。マスクレジスタの1番地ってことになりますね。マスクレジスタは条件分岐を実現するための特殊なレジスタであり、ビットの状態によって計算をスキップしたりします。自分のPEが持つIDと0を論理和演算してマスクレジスタに代入していることになりますね。4bitしかないので半語で扱うのかな？

### 感想とかいろろ
MN-CoreのPEについてわかってきたが、メモリ転送に関しては、まだまだ分からない

### 積み残し
サンプルコードのまだ読んでない残りの行があるので、明日は残りの行を読んでいきます。

***

# 8/27 つづきとか

## やったこと
引き続きサンプルコードを読んでいきます。

#### nop命令
いわゆるnop命令であり、特に何もしないのであるが、MN-Coreでは転送などの待ちをnop命令で調整しないといけないらしい。
nopのあとに**/**がついていることがあるが、これは複数回動かすことを示すためのシンタックスシュガーらしい

#### passa命令
コピー命令である。MN-Coreの命令に接頭辞をつけちゃう命名スタイルは正直すごく読みにくい
```
lpassa $lr2 $lr0/$imr1
```
というプログラムは、まず接頭辞の`l`がついているので長語でのコピーを表している。次に第一オペランドである**$lr2**はコピーもとであろう、GRF0の2番地ということになる。
最後の**$lr0/$imr1**とあるが、$lr0は書き込み先のレジスタと先頭の番地であり、$imr1は書き込みのマスクであると考えられる。

#### l1bmr命令
```
l1bmrsbor $llr0v $llb0
```
この命令はに L1BM-L2BM 間の転送を行う命令であるのでかなりややこしい。

この命令の構造は以下ののような感じになってる
```
l1bmr<rrn_opcode> <src> $lb<addr_b>
```
オペコードの意味を考えると

- **&ltrrn_opcode&gt**は縮約演算していというものでsborはshort型（半語）でborは論理orを表している。
- **src**
orしているのでそれぞれのpeから1ワードづつ読み出して、それぞれのPE番目のデータとPEのメモリのsrcからcycleでインクリメント下値をorを計算しているっぽい？難しすぎる。

意味がわからなすぎるので疑似コードを頑張って読んでいく
```
for cycle = 0:4 //４回繰り返す
    forall group,l2b,l1b　//すべてのブロックで演算を行う。
      LongWord data[4]　//配列の宣言
      data[:] = get_unit_value(rrn_opcode) //PEメモリのオペランドの単位元を入れる。orだったら全部０
      forall mab,pe //すべてのmabおよびpeで演算をする？
          //dataうちPEのIDが対応するアドレスに対してdataのPEのIDが対応するものと、サイクル番目のアドレスのデータを読み出してor
          data[pe] = rrn_opcode(data[pe], MEM[group][l2b][l1b][mab][pe].refer_pemem(src,cycle))　
      uint_t dst_addr = addr_b + cycle * 4　//出力アドレスをインクリメント
      MEM[group][l2b][l1b].l1bm[dst_addr:dst_addr+4] = data[0:4] //4こベクトルでコピー
```


#### l2bmr命令



#### mvp命令
mv命令は複雑らしい、PFNの人が文法が複雑だって言うんだから俺に理解するのは無理だろう
mvp/n64i01 $lc0 $d0
まずmvのあとについている**n64**は転送サイズが64byteであることを表しているらしい。その後の**i01**はタグ番号らしい。
第２オペランドが転送元であるL2BM、第３オペランドDRAMであり転送先を表す。
つまりこの命令はL2BMの０番地からDRAMの０番地へ転送するという認識でいいのかな？

#### 全体を読み直す
```
imm ui"0" $n0          # LM1の0番地に半語として0を書き込む
imm ui"0x48656c6c" $r2 # GRF0の2番地に半語として"0x48656c6c"を書き込む
imm ui"0x6f2c2077" $r3 # GRF0の3番地に半語として"0x6f2c2077"を書き込む
imm ui"0x6f726c64" $r0 # GRF0の0番地に半語として"0x6f726c64"を書き込む
imm ui"0x21000000" $r1 # GRF0の1番地に半語として"0x21000000"を書き込む

sor $subpeid $n0 $omr1 #半精度（半語）で自分のPE番号と、LM1の０番地（つまり０）とorを計算する
nop                    # １サイクル休み
lpassa $lr2 $lr0/$imr1 # GRF0の２番地の内容をGRF0の０番地にマスクして長語でコピーする（２を先頭として４アドレス行われる？）

nop/2                  # 2サイクル休み

# d get $lr0n0c0b0m0 1

l1bmrsbor $llr0v $llb0 #GRF0の０番地を２長語でorしてGRF1の０番地に書き込む
nop/3

# d get $lb0n0c0b0 1

l2bmrsbor $lb0 $lc0

# d get $lc0n0c0 1

nop/3
mvp/n64i01 $lc0 $d0
nop; wait i01
```

## 感想
RISCしか触ってこなかったので、正直なところ意味不明過ぎて困惑している。RISC-Vのベクトル命令ですら混乱するのに、なんやこれ？

### 積み残し
例題をときたかったけど、まだ終わってない。明日からコンテスト開場なので頑張りたい。

***